#!/usr/bin/python3
import abc
import stat
import sys, os
import threading
import randomname
import dotenv

sys.path.extend(os.getcwd() + "/bin")


class PathDescriptor:
    def __init__(self):
        super().__init__()
        self.name = "path"

    class Contain(list):
        def __init__(self, origin):
            list.__init__(self)
            self.origin = origin

        def append(self, __object: str) -> None:
            self.origin.path_append(__object)

        def extend(self, seq) -> None:
            self.origin.path_extend(seq)

        def __list__(self):
            return os.getenv("PATH").split(":")

        def __getitem__(self, item):
            return os.getenv("PATH").split(":").__getitem__(item)

        def __setitem__(self, index, item):
            pth = self.__list__()
            pth[index] = item
            os.environ["PATH"] = ":".join(pth)

        def __repr__(self):
            return f"PATH : {os.getenv('PATH')} object at {id(self)}"

        def __str__(self):
            return os.getenv('PATH')

    def __get__(self, instance, owner):
        return self.Contain(self)

    def __set__(self, instance, v):
        return self.path_set(v)

    def path_append(self, path):
        sp = os.getenv("PATH").split(":")
        sp.append(path)
        os.environ["PATH"] = ":".join(sp)
        return os.getenv("PATH")

    def path_set(self, path):
        if isinstance(path, str):

            os.environ["PATH"] = path
        else:
            os.environ["PATH"] = ":".join(path)

        return os.getenv("PATH")

    def path_extend(self, paths):
        sp = os.getenv("PATH").split(":")
        sp.extend(paths)
        os.environ["PATH"] = ":".join(sp)
        return os.getenv("PATH")


import rpyc
from rpyc.cli.rpyc_classic import ClassicServer


class MmSreverAttrDescriptor:

    def __get__(self, item, own):
        return getattr(item.MmSrever, self.name)

    def __set_name__(self, owner, name):
        self.name = name

    def __set__(self, item, v):
        setattr(item.MmSrever, self.name, v)


class mmctl:
    rpyc_threads = {}
    class MmSrever(ClassicServer):
        _spec = {}

        @classmethod
        def spec(cls):
            return cls.__dict__

    path = PathDescriptor()

    @property
    def dotenv(self):
        return dotenv.dotenv_values(dotenv.find_dotenv(".env", usecwd=True))

    @property
    def env(self):
        os.environ |= self.dotenv
        return os.environ

    def __init__(self):
        super().__init__()
        self.make_exec_all()

    def __call__(self, *args, **kwargs):
        for k, v in kwargs.items():
            if hasattr(self.MmSrever, k):
                setattr(self.MmSrever, k, v)

    @property
    def binary_dir(self):
        return os.getcwd() + "/bin"

    def make_exec_all(self):
        self.path.append(self.binary_dir)
        for item in os.scandir(self.binary_dir):
            print(item)
            os.chmod(item.path, mode=stat.S_IEXEC)

    def generate_rpyc_thread(self, name, **kwargs):
        if name is None:
            randomname.generate(sep="_")
        self._rpyc_thread
        self._rpyc_thread = threading.Thread(target=self.MmSrever.run, name="mmcore_rpyc")

    @property
    def rpyc_thread(self):
        return self._rpyc_thread

    def start_rpyc(self, argv):

        return self.server_thread

    def stop_rpyc(self, argv):
        self.server_thread.join(600)
        return self.server_thread
